# Сравнение текущей и новой архитектуры

## Проблемы текущей реализации

### 1. Корзина работает только для файлов
**Текущая реализация:**
- Файлы: помечаются `deleted_at`, остаются в БД
- Папки: удаляются навсегда (`instance.delete()` в `FolderViewSet.perform_destroy`)
- При удалении папки файлы внутри помечаются как deleted, но сама папка теряется

**Проблема:**
```python
# views.py:199-202
@transaction.atomic
def perform_destroy(self, instance):
    files = File.objects.filter(folder=instance, deleted_at__isnull=True)
    files.update(deleted_at=timezone.now())
    instance.delete()  # Папка удаляется навсегда!
```

Пользователь не может восстановить удаленную папку, даже если файлы внутри еще в корзине.

### 2. Нет информации о месте удаления
**Текущая реализация:**
- `File.deleted_at` - только время удаления
- Нет информации о том, из какой папки был удален файл

**Проблема:**
При восстановлении файл не знает, куда вернуться. Нужно либо восстанавливать в корень, либо терять контекст.

### 3. Разные endpoints для файлов и папок
**Текущая реализация:**
- `/api/files/` - для файлов
- `/api/folders/` - для папок
- `/api/folders/{id}/content/` - отдельный endpoint для содержимого папки

**Проблема:**
Фронтенд должен делать два запроса для отображения содержимого папки:
```javascript
// Нужно два запроса
const folders = await fetch('/api/folders/?parent_id=123');
const files = await fetch('/api/files/?folder_id=123');
```

### 4. Разные форматы ответов
**Текущая реализация:**
- `FileSerializer`: `id`, `name`, `size`, `mime_type`, `uploaded_at`, `folder`, `preview_url`, `download_url`
- `FolderSerializer`: `id`, `name`, `created_at`, `files`, `children`, `parent`

**Проблема:**
Фронтенд должен обрабатывать два разных формата. Нет единого поля `type` для определения типа элемента.

### 5. Рекурсивная сериализация папок
**Текущая реализация:**
```python
# serializers.py:51-52
def get_children(self, obj):
    return FolderSerializer(obj.children.all(), many=True, context=self.context).data
```

**Проблема:**
При запросе одной папки сериализуются все вложенные папки и файлы. Это неэффективно для больших структур.

### 6. Нет единого способа работы с элементами
**Текущая реализация:**
- Для файла: `FileViewSet`
- Для папки: `FolderViewSet`
- Разная логика в разных местах

**Проблема:**
Дублирование кода, сложность поддержки, нет единой точки входа.

## Преимущества новой архитектуры

### 1. Корзина для всех элементов
**Новая реализация:**
- `TrashItem` - отдельная модель с GenericForeignKey
- Может хранить и файлы, и папки
- При удалении папки создается TrashItem для папки и рекурсивно для содержимого
- Все элементы можно восстановить

**Преимущество:**
Пользователь может восстановить удаленную папку со всей структурой.

### 2. Сохранение контекста удаления
**Новая реализация:**
```python
class TrashItem(models.Model):
    original_parent_id = models.BigIntegerField(null=True)  # Для Folder
    original_folder_id = models.UUIDField(null=True)  # Для File
```

**Преимущество:**
При восстановлении элемент возвращается в исходное место.

### 3. Единый endpoint для контента
**Новая реализация:**
```http
GET /api/filesystem/items/?parent_id=123
```

**Ответ:**
```json
{
  "items": [
    {"id": "uuid", "type": "file", "name": "doc.pdf", ...},
    {"id": 456, "type": "folder", "name": "Documents", ...}
  ]
}
```

**Преимущество:**
Один запрос вместо двух. Единый формат ответа.

### 4. Единый формат с полем type
**Новая реализация:**
Все элементы имеют поле `type: "file" | "folder"` и общие поля.

**Преимущество:**
Фронтенд может обрабатывать элементы единообразно:
```javascript
items.forEach(item => {
  if (item.type === 'file') {
    // Показать файл
  } else if (item.type === 'folder') {
    // Показать папку
  }
});
```

### 5. Ленивая загрузка содержимого
**Новая реализация:**
- `/api/filesystem/items/` - только прямые дети
- `/api/filesystem/items/{id}/content/` - явный запрос содержимого

**Преимущество:**
Нет лишних данных, быстрее загрузка, меньше трафика.

### 6. Единый ViewSet
**Новая реализация:**
- `FileSystemItemViewSet` - работает с обоими типами
- `get_serializer_class()` определяет тип автоматически

**Преимущество:**
Меньше дублирования, проще поддержка, единая логика.

## Миграционный путь

### Этап 1: Добавить TrashItem без удаления старого кода

1. Создать модель `TrashItem`
2. Добавить миграцию данных: существующие `File.deleted_at` → создать `TrashItem`
3. Оставить `File.deleted_at` пока (для обратной совместимости)

### Этап 2: Создать новые endpoints параллельно

1. Создать `FileSystemItemViewSet` с новыми endpoints
2. Оставить старые `/api/files/` и `/api/folders/` работающими
3. Фронтенд постепенно переходит на новые endpoints

### Этап 3: Обновить логику удаления

1. Обновить `FileViewSet.perform_destroy` - создавать `TrashItem` вместо `deleted_at`
2. Обновить `FolderViewSet.perform_destroy` - создавать `TrashItem` вместо удаления
3. Обновить `trash` action - использовать `TrashItem`

### Этап 4: Убрать старые endpoints

1. После полного перехода фронтенда - удалить старые ViewSets
2. Удалить `File.deleted_at` из модели
3. Очистить старые миграции

## Обратная совместимость

Новая архитектура может сосуществовать со старой:

1. **Двойная запись при удалении:**
   ```python
   # Создаем TrashItem
   TrashItem.objects.create(...)
   # Но оставляем deleted_at для совместимости
   file.deleted_at = timezone.now()
   file.save()
   ```

2. **Старые endpoints продолжают работать:**
   - `/api/files/` - использует `File.deleted_at`
   - `/api/filesystem/items/` - использует `TrashItem`

3. **Постепенный переход:**
   - Фронтенд может использовать оба API
   - Постепенно мигрировать на новый

## Производительность

### Текущая реализация
- Запрос файлов: `SELECT * FROM files WHERE folder_id = X AND deleted_at IS NULL`
- Запрос папок: `SELECT * FROM folders WHERE parent_id = X`
- Два запроса к БД

### Новая реализация
- Один запрос с UNION или два оптимизированных запроса
- Индексы на `TrashItem(owner, deleted_at)` для быстрого поиска
- Ленивая загрузка - только нужные данные

## Итоговое сравнение

| Аспект | Текущая реализация | Новая реализация |
|--------|-------------------|------------------|
| Корзина для папок | ❌ Нет | ✅ Да |
| Восстановление контекста | ❌ Нет | ✅ Да |
| Единый endpoint | ❌ Нет (2 endpoints) | ✅ Да (1 endpoint) |
| Единый формат | ❌ Нет | ✅ Да (поле type) |
| Рекурсивная загрузка | ⚠️ Всегда | ✅ По запросу |
| Код дублирование | ⚠️ Есть | ✅ Минимум |
| Обратная совместимость | - | ✅ Можно сохранить |
